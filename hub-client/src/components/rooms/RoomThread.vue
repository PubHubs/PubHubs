<template>
	<div ref="elThreadTimeline" class="relative flex h-full w-full shrink-0 flex-col border-l border-surface-high bg-background md:w-[33%]">
		<!-- Thread header -->
		<div class="m-3 mb-0 flex items-center gap-2 rounded-md bg-surface-low p-2">
			<button @click="closeThread" class="rounded-md p-1">
				<Icon :type="'arrow'" :size="'sm'"></Icon>
			</button>
			<p class="truncate text-nowrap ~text-label-tiny-min/label-tiny-max">Thread ({{ numberOfThreadEvents }})</p>
		</div>

		<!-- Thread message list -->
		<div class="h-full flex-1 overflow-y-scroll pb-8 pt-4">
			<!-- Root event -->
			<div v-if="filteredEvents.length === 0" ref="elRoomEvent" :id="props.room.currentThread?.rootEvent?.event.event_id">
				<RoomMessageBubble
					:room="room"
					:event="props.room.currentThread?.rootEvent?.event"
					:viewFromThread="true"
					:active-profile-card="activeProfileCard"
					:active-reaction-panel="activeReactionPanel"
					class="room-event"
					@in-reply-to-click="onInReplyToClick"
					@delete-message="confirmDeleteMessage"
					@profile-card-toggle="toggleProfileCard"
					@profile-card-close="closeProfileCard"
					@reaction-panel-toggle="toggleReactionPanel"
					@reaction-panel-close="closeReactionPanel"
					@clicked-emoticon="sendEmoji"
				>
				</RoomMessageBubble>

				<div class="flex flex-wrap gap-2 px-20">
					<Reaction v-if="reactionExistsForMessage(props.room.currentThread?.rootEvent?.event.event_id)" :reactEvent="onlyReactionEvents" :messageEventId="props.room.currentThread?.rootEvent?.event.event_id" />
				</div>
			</div>

			<!-- Thread replies -->
			<div v-for="item in filteredEvents" :key="item.matrixEvent.event.event_id">
				<div class="mx-3 rounded-md" ref="elRoomEvent" :id="item.matrixEvent.event.event_id">
					<RoomMessageBubble
						:room="room"
						:event="item.matrixEvent.event"
						:viewFromThread="true"
						:active-profile-card="activeProfileCard"
						:active-reaction-panel="activeReactionPanel"
						class="room-event"
						@clicked-emoticon="sendEmoji"
						@in-reply-to-click="onInReplyToClick"
						@delete-message="confirmDeleteMessage"
						@profile-card-toggle="toggleProfileCard"
						@profile-card-close="closeProfileCard"
						@reaction-panel-toggle="toggleReactionPanel"
						@reaction-panel-close="closeReactionPanel"
					></RoomMessageBubble>

					<!-- Reaction display for message -->
					<div class="flex flex-wrap gap-2 px-20">
						<Reaction v-if="reactionExistsForMessage(item.matrixEvent.event.event_id)" :reactEvent="onlyReactionEvents" :messageEventId="item.matrixEvent.event.event_id" />
					</div>
				</div>
			</div>
		</div>

		<!-- Thread input -->
		<MessageInput class="z-10 -mt-4" v-if="room" :room="room" :in-thread="true"></MessageInput>
	</div>

	<!-- Delete message dialog -->
	<DeleteMessageDialog v-if="showConfirmDelMsgDialog" :event="eventToBeDeleted" :room="room" :view-from-thread="true" @close="showConfirmDelMsgDialog = false" @yes="deleteMessage(eventToBeDeleted)"></DeleteMessageDialog>
</template>

<script setup lang="ts">
	// Packages
	import { MatrixEvent } from 'matrix-js-sdk';
	import { Reactive, computed, nextTick, onMounted, onUnmounted, reactive, ref, watch } from 'vue';

	// Components
	import DeleteMessageDialog from '@hub-client/components/forms/DeleteMessageDialog.vue';
	import MessageInput from '@hub-client/components/forms/MessageInput.vue';
	import RoomMessageBubble from '@hub-client/components/rooms/RoomMessageBubble.vue';
	import Reaction from '@hub-client/components/ui/Reaction.vue';

	// Logic
	import { LOGGER } from '@hub-client/logic/logging/Logger';
	import { SMI } from '@hub-client/logic/logging/StatusMessage';

	// Models
	import { RelationType, RoomEmit } from '@hub-client/models/constants';
	import { TMessageEvent, TMessageEventContent } from '@hub-client/models/events/TMessageEvent';
	import { TimelineEvent } from '@hub-client/models/events/TimelineEvent';
	import Room from '@hub-client/models/rooms/Room';

	import { usePubhubsStore } from '@hub-client/stores/pubhubs';

	const props = defineProps({
		room: {
			type: Room,
			required: true,
		},
		scrollToEventId: String,
	});

	const pubhubs = usePubhubsStore();

	let deletedEvents: Reactive<MatrixEvent[]> = reactive<MatrixEvent[]>([]);
	let threadEvents: Reactive<TimelineEvent[]> = reactive<TimelineEvent[]>([]);
	const emit = defineEmits([RoomEmit.ThreadLengthChanged, RoomEmit.ScrolledToEventId]);

	const activeProfileCard = ref<string | null>(null);
	const activeReactionPanel = ref<string | null>(null);

	const filteredEvents = computed(() => {
		return threadEvents.filter((event) => !event.isDeleted);
	});

	const numberOfThreadEvents = computed(() => Math.max(filteredEvents.value.length, 1));

	const onlyReactionEvents = computed(() => {
		props.room.getRelatedEvents().forEach((reactEvent) => props.room.addCurrentEventToRelatedEvent(reactEvent));
		return props.room.getCurrentEventRelatedEvents();
	});

	watch(
		() => props.room.threadUpdated,
		() => getThreadEvents(),
	);

	watch(
		() => props.room.currentThread?.threadId,
		() => changeThreadId(),
		{ immediate: true },
	);

	watch(
		() => props.scrollToEventId,
		(newValue, oldValue) => {
			nextTick(() => onScrollToEventId(newValue, oldValue));
		},
		{ immediate: true },
	);

	watch(
		() => filteredEvents.value.length,
		() => emit(RoomEmit.ThreadLengthChanged, numberOfThreadEvents.value),
	);

	const elThreadTimeline = ref<HTMLElement | null>(null);
	const showConfirmDelMsgDialog = ref(false);
	const eventToBeDeleted = ref<TMessageEvent>();

	onMounted(() => {
		LOGGER.log(SMI.ROOM_THREAD, 'RoomThread mounted');
	});

	onUnmounted(() => {
		closeThread();
	});

	function closeThread() {
		props.room.setCurrentThreadId(undefined);
	}

	async function changeThreadId() {
		await getThreadEvents();
		if (props.room.getCurrentEvent()) {
			scrollToEvent(props.room.getCurrentEvent()!.eventId, { position: 'center', select: 'Highlight' });
		} else {
			const lastEvent = filteredEvents.value[filteredEvents.value.length - 1];
			if (lastEvent?.matrixEvent.event?.event_id) {
				scrollToEvent(lastEvent.matrixEvent.event.event_id, { position: 'end' });
			}
		}
	}

	async function onScrollToEventId(newEventId?: string, oldEventId?: string) {
		if (!newEventId) return;
		scrollToEvent(newEventId, { position: 'center', select: 'Highlight' });
	}

	async function getThreadEvents() {
		const events = await props.room.getCurrentThreadEvents();
		threadEvents.splice(0, threadEvents.length, ...events);

		if (threadEvents.length > 0) {
			nextTick(() => scrollToEvent(threadEvents[threadEvents.length - 1].matrixEvent.event.event_id!));
		}
	}

	function onInReplyToClick(inReplyToId: string) {
		scrollToEvent(inReplyToId, { position: 'center', select: 'Highlight' });
	}

	async function scrollToEvent(eventId: string, options: { position: 'start' | 'center' | 'end'; select?: 'Highlight' | 'Select' } = { position: 'start' }) {
		LOGGER.log(SMI.ROOM_THREAD, `scroll to event: ${eventId}`, { eventId });

		const doScroll = (elEvent: Element) => {
			elEvent.scrollIntoView({ block: options.position });
			if (options.select === 'Highlight') {
				elEvent.classList.add('highlighted');
				window.setTimeout(() => {
					elEvent.classList.add('unhighlighted');
					window.setTimeout(() => {
						elEvent.classList.remove('highlighted');
					}, 500);
				}, 2000);
			}
		};

		if (elThreadTimeline.value) {
			const elEvent = elThreadTimeline.value?.querySelector(`[id="${eventId}"]`);
			if (elEvent) {
				doScroll(elEvent);
				emit(RoomEmit.ScrolledToEventId);
			}
		}
	}

	function confirmDeleteMessage(event: TMessageEvent) {
		eventToBeDeleted.value = event;
		showConfirmDelMsgDialog.value = true;
	}

	function deleteMessage(event: TMessageEvent<TMessageEventContent> | undefined) {
		if (event) {
			let deletedEvent = threadEvents.find((e) => e.matrixEvent.event.event_id === event.event_id);
			props.room.deleteThreadMessage(event, deletedEvent?.matrixEvent.threadRootId);
			if (deletedEvent) {
				deletedEvents.push(deletedEvent.matrixEvent as MatrixEvent);
			}
		}
	}

	function toggleProfileCard(eventId: string) {
		activeProfileCard.value = activeProfileCard.value === eventId ? null : eventId;
	}

	function closeProfileCard() {
		activeProfileCard.value = null;
	}

	function toggleReactionPanel(eventId: string) {
		activeReactionPanel.value = activeReactionPanel.value === eventId ? null : eventId;
	}
	function closeReactionPanel() {
		activeReactionPanel.value = null;
	}

	async function sendEmoji(emoji: string, eventId: string) {
		await pubhubs.addReactEvent(props.room.roomId, eventId, emoji);
	}

	function reactionExistsForMessage(messageEventId: string): boolean {
		if (!onlyReactionEvents.value) return false;

		const reactionEvent = onlyReactionEvents.value.find((event) => {
			const relatesTo = event.getContent()[RelationType.RelatesTo];
			return relatesTo && relatesTo.event_id === messageEventId;
		});

		if (reactionEvent) {
			const relatesTo = reactionEvent.getContent()[RelationType.RelatesTo];
			return !!relatesTo?.key;
		}

		return false;
	}
</script>
