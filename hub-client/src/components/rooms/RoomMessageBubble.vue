<template>
	<div ref="elReactionPopUp">
		<!-- Plugin Event -->
		<div v-if="event.plugin && event.plugin.plugintype === PluginType.EVENT && event.type === event.plugin.type">
			<component :is="event.plugin.component" :event="event">{{ event.plugin.component }}</component>
		</div>

		<!-- Normal Event -->
		<div v-else class="group flex flex-col py-3" :class="getMessageContainerClasses" role="article">
			<!-- Announcement Header -->
			<div v-if="isAnnouncementMessage && !redactedMessage" class="flex w-full items-center bg-surface-high px-8 py-1 ~text-label-small-min/label-small-max" :class="{ 'mx-4': props.deleteMessageDialog }">
				<Icon type="announcement" size="sm" class="mr-1"></Icon>
				{{ getAnnouncementTitle }}
			</div>

			<!-- Message Container -->
			<div class="relative flex w-full gap-2 px-6" :class="getMessageContainerClasses">
				<!-- Reaction Panel -->
				<div v-if="showReactionPanel" :class="['absolute bottom-full right-0 z-50', calculatePanelPlacement() ? 'bottom-full' : 'top-8']">
					<ReactionMiniPopUp :eventId="event.event_id" :room="room" @emoji-selected="emit('clickedEmoticon', $event, event.event_id)" @close-panel="emit('reactionPanelClose')" />
				</div>

				<!-- Avatar -->
				<Avatar
					:avatar-url="user.userAvatar(event.sender)"
					:user-id="event.sender"
					@click.stop="emit('profileCardToggle', event.event_id)"
					:class="['transition-all duration-500 ease-in-out', { 'cursor-pointer ring-1 ring-on-surface-dim ring-offset-4': hover || props.activeProfileCard === props.event.event_id }]"
					@mouseover="hover = true"
					@mouseleave="hover = false"
				/>

				<!-- Profile Card -->
				<div class="relative">
					<Popover v-if="showProfileCard" @close="emit('profileCardClose')" :class="['absolute z-50 h-40 w-52', profileInPosition(event) ? 'bottom-4' : '']">
						<ProfileCard :event="event" :room="room" :room-member="roomMember" />
					</Popover>
				</div>

				<!-- Message and Actions -->
				<div :class="{ 'w-5/6': deleteMessageDialog, 'w-full': !deleteMessageDialog }" class="min-w-0">
					<div class="flex flex-wrap items-center overflow-hidden text-wrap break-all">
						<div class="relative flex min-h-6 w-full items-start gap-x-2 pb-1">
							<div class="flex w-full min-w-0 flex-grow flex-wrap items-center gap-2">
								<UserDisplayName :userId="event.sender" />
								<span class="flex gap-2">
									<span class="~text-label-small-min/label-small-max">|</span>
									<EventTime :timestamp="event.origin_server_ts" :showDate="false" />
									<span class="~text-label-small-min/label-small-max">|</span>
									<EventTime :timestamp="event.origin_server_ts" :showDate="true" />
								</span>
								<RoomBadge v-if="!room.directMessageRoom()" class="inline-block" :user="event.sender" :room_id="event.room_id" />
							</div>

							<!-- Message Action Buttons -->
							<div>
								<template v-if="timerReady && !deleteMessageDialog">
									<button v-if="msgIsNotSend && connection.isOn" @click="resend()" class="mb-1 ml-2" :title="t('errors.resend')">
										<Icon type="refresh" size="sm" class="text-red" />
									</button>
									<Icon v-if="msgIsNotSend && !connection.isOn" type="lost-connection" size="sm" class="text-red mb-1 ml-2" />
								</template>

								<RoomEventActionsPopup v-if="!deleteMessageDialog" :remain-active="openEmojiPanel">
									<!-- Reaction Button -->
									<button
										@click.stop="emit('reactionPanelToggle', props.event.event_id)"
										class="flex items-center justify-center rounded-md p-1 text-on-surface-variant transition-all duration-300 ease-in-out hover:w-fit hover:bg-accent-primary hover:text-on-accent-primary"
										:title="t('message.reply_emoji')"
									>
										<Icon type="emoji_smiley" size="sm" />
									</button>

									<!-- Reply Button -->
									<button
										v-if="!msgIsNotSend && !redactedMessage && !isThreadRoot"
										@click="reply"
										class="flex items-center justify-center rounded-md p-1 text-on-surface-variant transition-all duration-300 ease-in-out hover:w-fit hover:bg-accent-primary hover:text-on-accent-primary"
										:title="t('message.reply')"
									>
										<Icon :type="'reply'" size="sm" />
									</button>

									<!-- Thread Reply Button -->
									<button
										v-if="!viewFromThread && threadLength <= 0 && canReplyInThread && !msgIsNotSend && !redactedMessage"
										@click="replyInThread"
										class="flex items-center justify-center rounded-md p-1 text-on-surface-variant transition-all duration-300 ease-in-out hover:w-fit hover:bg-accent-primary hover:text-on-accent-primary"
										:title="t('message.reply_in_thread')"
									>
										<Icon :type="'talk'" size="'xs'" />
									</button>

									<!-- Disclosure Button -->
									<button
										v-if="!msgIsNotSend && user.isAdmin && event.sender !== user.userId && settings.isFeatureEnabled(FeatureFlag.disclosure)"
										@click="router.push({ name: 'ask-disclosure', query: { user: event.sender } })"
										class="flex items-center justify-center rounded-md p-1 text-on-surface-variant transition-all duration-300 ease-in-out hover:w-fit hover:bg-accent-primary hover:text-on-accent-primary"
										:title="t('menu.moderation_tools_disclosure')"
									>
										<Icon :type="'warning'" size="sm" />
									</button>

									<!-- Delete Button -->
									<button
										v-if="settings.isFeatureEnabled(FeatureFlag.deleteMessages) && !msgIsNotSend && event.sender === user.userId && !redactedMessage && !(props.viewFromThread && isThreadRoot)"
										@click="onDeleteMessage(event)"
										class="flex items-center justify-center rounded-md p-1 text-on-surface-variant transition-all duration-300 ease-in-out hover:w-fit hover:bg-accent-red hover:text-on-accent-red"
										:title="t('menu.delete_message')"
									>
										<Icon :type="'bin'" size="sm" />
									</button>
								</RoomEventActionsPopup>
							</div>
						</div>
					</div>

					<!-- Plugin Message -->
					<template v-if="event.plugin?.plugintype === PluginType.MESSAGE && event.content.msgtype === event.plugin.type">
						<component :is="event.plugin.component" :event="event">{{ event.plugin.component }}</component>
					</template>

					<!-- Regular Message -->
					<template v-else>
						<Suspense>
							<MessageSnippet v-if="showReplySnippet(event.content.msgtype)" @click="onInReplyToClick" :eventId="inReplyToId" :showInReplyTo="true" :room="room" />
							<template #fallback>
								<div class="flex items-center gap-3 rounded-md px-2">
									<p>{{ t('state.loading_message') }}</p>
								</div>
							</template>
						</Suspense>

						<Message v-if="event.content.msgtype === MsgType.Text || redactedMessage" :event="event" :deleted="redactedMessage" class="max-w-[90ch]" />
						<AnnouncementMessage v-if="isAnnouncementMessage && !redactedMessage && !room.isPrivateRoom()" :event="event.content" />
						<MessageSigned v-if="event.content.msgtype === PubHubsMgType.SignedMessage && !redactedMessage" :message="event.content.signed_message" class="max-w-[90ch]" />
						<MessageFile v-if="event.content.msgtype === MsgType.File && !redactedMessage" :message="event.content" />
						<MessageImage v-if="event.content.msgtype === MsgType.Image && !redactedMessage" :message="event.content" />

						<VotingWidget
							v-if="settings.isFeatureEnabled(FeatureFlag.votingWidget) && event.content.msgtype === PubHubsMgType.VotingWidget && !redactedMessage"
							:event="event"
							@edit-poll="(poll, eventId) => emit('editPoll', poll, eventId)"
							@edit-scheduler="(scheduler, eventId) => emit('editScheduler', scheduler, eventId)"
						/>
					</template>

					<!-- Thread View Button -->
					<button
						@click="replyInThread"
						class="bg-hub-background-3 inline-flex rounded-md px-2 py-1 ~text-label-tiny-min/label-tiny-max hover:opacity-80"
						v-if="!deleteMessageDialog && !viewFromThread && threadLength > 0 && canReplyInThread && !msgIsNotSend && !redactedMessage"
					>
						<Icon :type="'talk'" size="'sm'" />
						&nbsp; {{ t('message.threads.view_thread') }} ({{ threadLength }})
					</button>
				</div>
			</div>

			<!-- Reactions Slot -->
			<div>
				<slot name="reactions"></slot>
			</div>
		</div>
	</div>
</template>

<script setup lang="ts">
	// Packages
	import { IEvent, MsgType } from 'matrix-js-sdk';
	import { PropType, computed, onBeforeUnmount, onMounted, ref, watch } from 'vue';
	import { useI18n } from 'vue-i18n';

	// Components
	import Icon from '@hub-client/components/elements/Icon.vue';
	import AnnouncementMessage from '@hub-client/components/rooms/AnnouncementMessage.vue';
	import EventTime from '@hub-client/components/rooms/EventTime.vue';
	import Message from '@hub-client/components/rooms/Message.vue';
	import MessageFile from '@hub-client/components/rooms/MessageFile.vue';
	import MessageImage from '@hub-client/components/rooms/MessageImage.vue';
	import MessageSigned from '@hub-client/components/rooms/MessageSigned.vue';
	import MessageSnippet from '@hub-client/components/rooms/MessageSnippet.vue';
	import RoomBadge from '@hub-client/components/rooms/RoomBadge.vue';
	import RoomEventActionsPopup from '@hub-client/components/rooms/RoomEventActionsPopup.vue';
	import UserDisplayName from '@hub-client/components/rooms/UserDisplayName.vue';
	import VotingWidget from '@hub-client/components/rooms/voting/VotingWidget.vue';
	import Avatar from '@hub-client/components/ui/Avatar.vue';
	import Popover from '@hub-client/components/ui/Popover.vue';
	import ProfileCard from '@hub-client/components/ui/ProfileCard.vue';
	import ReactionMiniPopUp from '@hub-client/components/ui/ReactionMiniPopUp.vue';

	// Logic
	import { PubHubsMgType } from '@hub-client/logic/core/events';
	import { router } from '@hub-client/logic/core/router';

	// Models
	import { RelationType } from '@hub-client/models/constants';
	import { TMessageEvent } from '@hub-client/models/events/TMessageEvent';
	import { Poll, Scheduler } from '@hub-client/models/events/voting/VotingTypes';
	import Room from '@hub-client/models/rooms/Room';

	// Stores
	import { useConnection } from '@hub-client/stores/connection';
	import { useMessageActions } from '@hub-client/stores/message-actions';
	import { PluginType } from '@hub-client/stores/plugins';
	import { usePubhubsStore } from '@hub-client/stores/pubhubs';
	import { FeatureFlag, useSettings } from '@hub-client/stores/settings';
	import { useUser } from '@hub-client/stores/user';

	const connection = useConnection();
	const messageActions = useMessageActions();
	const pubhubs = usePubhubsStore();
	const user = useUser();
	const settings = useSettings();
	const { t } = useI18n();
	const hover = ref(false);
	const openEmojiPanel = ref(false);
	const elReactionPopUp = ref<HTMLElement | null>(null);

	let roomMember = ref();
	let threadLength = ref(0);

	const props = defineProps({
		event: {
			type: Object,
			required: true,
		},
		eventThreadLength: {
			type: Number,
			default: 0,
		},
		room: {
			type: Room,
			required: true,
		},
		viewFromThread: {
			type: Boolean,
			default: false,
		},
		deletedEvent: {
			type: Boolean,
		},
		deleteMessageDialog: {
			type: Boolean,
			default: false,
		},
		activeProfileCard: {
			type: String as PropType<string | null>,
			default: null,
		},
		activeReactionPanel: {
			type: String as PropType<string | null>,
			default: null,
		},
	});

	onMounted(() => (threadLength.value = props.eventThreadLength));

	onBeforeUnmount(() => {
		// If the profile card is open when this component is unmounted, close it.
		if (props.activeProfileCard === props.event.event_id) {
			emit('profileCardClose');
		}
	});

	/**
	 * Watch the threadUpdated for new events coming from slidingsync
	 */
	watch(
		() => props.room.threadUpdated,
		() => {
			if (props.event.event_id === props.room.currentThread?.rootEvent?.event.event_id) {
				threadLength.value = (props.room.currentThread?.rootEvent?.getThread()?.length ?? 0) + 1; // length does not include rootEvent
			}
		},
	);

	const inReplyToId = props.event.content[RelationType.RelatesTo]?.[RelationType.InReplyTo]?.event_id;

	const emit = defineEmits<{
		(e: 'inReplyToClick', inReplyToId: string): void;
		(e: 'deleteMessage', event: TMessageEvent): void;
		(e: 'editPoll', poll: Poll, eventId: string): void;
		(e: 'editScheduler', scheduler: Scheduler, eventId: string): void;
		(e: 'profileCardToggle', eventId: string): void;
		(e: 'profileCardClose'): void;
		(e: 'reactionPanelToggle', eventId: string): void;
		(e: 'reactionPanelClose'): void;
		(e: 'clickedEmoticon', emoji: string, eventId: string): void;
	}>();

	const showProfileCard = computed(() => props.activeProfileCard === props.event.event_id);

	const showReactionPanel = computed(() => props.activeReactionPanel === props.event.event_id);

	const msgIsNotSend = computed(() => props.event.event_id.substring(0, 1) === '~');

	const canReplyInThread = computed(() => !props.event.content[RelationType.RelatesTo]);

	const isThreadRoot = computed(() => props.room.currentThread?.threadId === props.event.event_id);

	const containsRedactedBecause = props.event.unsigned?.redacted_because !== undefined;

	const redactedMessage = computed(() => {
		return props.deletedEvent || containsRedactedBecause;
	});

	const isAnnouncementMessage = computed(() => props.event.content.msgtype === PubHubsMgType.AnnouncementMessage);

	const getAnnouncementTitle = computed(() => getUserTitleForAnnouncement(props.event.sender));

	// Styling of the event based on announcment message
	const getMessageContainerClasses = computed(() => {
		// Base classes
		const baseClasses = {
			'p-2 transition-all duration-150 ease-in-out hover:bg-surface-low': !props.deleteMessageDialog,
			'mx-4 rounded shadow-[0_0_5px_0_rgba(0,0,0,0.3)]': props.deleteMessageDialog,
			'rounded-t-none': isAnnouncementMessage.value,
		};

		// Return base classes if not an announcement or is redacted
		if (!isAnnouncementMessage.value || redactedMessage.value) {
			return baseClasses;
		}

		// Common announcement classes
		const commonAnnouncementClasses = {
			'bg-surface-low': true,
		};

		return {
			...baseClasses,
			...commonAnnouncementClasses,
		};
	});

	/**
	 * Determines the announcement title based on user power level
	 * - Power level 50 = Steward
	 * - Power level 100 = Room Administrator
	 */
	function getUserTitleForAnnouncement(userId: string): string {
		const powerLevel = props.room.getPowerLevel(userId);
		if (powerLevel >= 50 && powerLevel < 100) return announcementTitle(t('rooms.steward'));
		else if (powerLevel === 100) return announcementTitle(t('rooms.administrator'));
		else return ''; // empty title will not display anything.
	}

	function announcementTitle(role: string): string {
		return t('rooms.room') + ' ' + role + ' ' + t('rooms.announcement');
	}

	/**
	 * Returns boolean whether the reply snippet can be shown
	 * When in a thread: images and files always get an reply, so it is not clear if they are meant to be a reply.
	 * Like Element we remove the replysnippet in that case.
	 */
	function showReplySnippet(msgType: string): boolean {
		if (props.viewFromThread) {
			if (msgType === MsgType.Image || msgType === MsgType.File) {
				return false;
			}
		}
		return !!inReplyToId && !redactedMessage.value;
	}

	function onInReplyToClick() {
		if (!inReplyToId) return;
		emit('inReplyToClick', inReplyToId);
	}

	function onDeleteMessage(event: TMessageEvent) {
		emit('deleteMessage', event);
	}

	function reply() {
		messageActions.replyingTo = props.event.event_id;
	}

	function replyInThread() {
		props.room.setCurrentThreadId(props.event.event_id);
	}

	function resend() {
		pubhubs.resendEvent(props.event);
	}

	function profileInPosition(ev: Partial<IEvent>) {
		return ev.event_id === props.room.getLastVisibleEventId() && props.room.numOfMessages() > 5;
	}

	// Positions the panel based on whether the message event is near the bottom of the screen
	// or near the top.
	function calculatePanelPlacement(): boolean {
		const position = elReactionPopUp.value?.getBoundingClientRect();
		if (!position) return false;
		// If the top of the bubble is below the middle of the viewport, open upwards
		return position.top > window.innerHeight / 2;
	}

	// Waits for checking if message is realy send. Otherwise a 'resend' button appears. See also msgIsNotSend computed.
	const timerReady = ref(false);
	window.setTimeout(() => {
		timerReady.value = true;
	}, 1000);
</script>
