//! Configuration (files)
use core::fmt::Debug;
use std::net::SocketAddr;
use std::path::{Path, PathBuf};

use anyhow::{Context as _, Result};
use url::Url;

use crate::servers::{for_all_servers, server::Server as _};
use crate::{
    api::{self},
    elgamal, hub,
};

/// Configuration for one, or several, of the PubHubs servers
///
/// Also used for the `pubhubs admin` cli command.  In that case only `phc_url` needs to be set.
#[derive(serde::Deserialize, serde::Serialize, Debug, Clone)]
#[serde(deny_unknown_fields)]
pub struct Config {
    /// URL of the PubHubs Central server.
    ///
    /// Any information on the other servers that can be stored at PHC is stored at PHC.
    pub phc_url: Url,

    /// Path with respect to which relative paths are interpretted.
    #[serde(default)]
    pub wd: PathBuf,

    /// Configuration to run PubHubs Central
    pub phc: Option<ServerConfig<phc::ExtraConfig>>,

    /// Configuration to run the Transcryptor
    pub transcryptor: Option<ServerConfig<transcryptor::ExtraConfig>>,

    /// Configuration to run the Authentication Server
    pub auths: Option<ServerConfig<auths::ExtraConfig>>,
}

/// Configuration for one server
#[derive(serde::Deserialize, serde::Serialize, Debug, Clone)]
#[serde(deny_unknown_fields)]
pub struct ServerConfig<ServerSpecific> {
    pub bind_to: SocketAddr,

    /// Random string used by this server to identify itself.  Randomly generated if not set.
    /// May be set manually when multiple instances of the same server are used.
    pub self_check_code: Option<String>,

    /// Key used to sign JSON web tokens generated by this server.
    /// If `None`, one is generated automatically (which is not suitable for production.)
    pub jwt_key: Option<api::SigningKey>,

    /// Each server advertises an [`elgamal::PublicKey`] so that shared secrets may be established
    /// with this server, and also encrypted messages may be sent to it.
    ///
    /// This key is also used to derive non-permanent secrets, like the the transcryptor's
    /// encryption factor f_H for a hub H.
    pub enc_key: Option<elgamal::PrivateKey>,

    /// When stopping this server (for example, during discovery) have actix shutdown gracefully.
    /// Makes discovery much slower; only recommended for production.  Defaults to false when
    /// debug_assertions are true.
    #[serde(default = "default_graceful_shutdown")]
    pub graceful_shutdown: bool,

    /// Key used by admin to sign requests for the admin endpoints.
    /// If `None`, one is generated automatically and the private key is  printed to the log.
    pub admin_key: Option<api::VerifyingKey>,

    #[serde(flatten)]
    pub extra: ServerSpecific,
}

fn default_graceful_shutdown() -> bool {
    !cfg!(debug_assertions)
}

impl Config {
    /// Loads [Config] from `path` and generates random values.
    ///
    /// Returns [None] if there's no file there.
    pub fn load_from_path(path: &Path) -> Result<Option<Self>> {
        let file = match std::fs::File::open(path) {
            Ok(file) => file,
            Err(e) => match e.kind() {
                std::io::ErrorKind::NotFound => return Ok(None),
                _ => {
                    return Err(e)
                        .with_context(|| format!("could not open config file {}", path.display()))
                }
            },
        };

        let mut res: Self = serde_yaml::from_reader(file)
            .with_context(|| format!("could not parse config file {}", path.display()))?;

        if res.wd.as_os_str().is_empty() {
            res.wd = path
                .canonicalize()
                .with_context(|| format!("failed to canonicalize path {}", path.display()))?
                .parent()
                .expect("did not expect a configuration file without a parent directory")
                .into();
        }

        if !res.wd.is_absolute() {
            anyhow::bail!(
                "if you specify a working directory (`wd` in {}) it must be absolute",
                path.display()
            );
        }

        log::info!(
            "loaded config file from {};  interpretting relative paths in {}",
            path.display(),
            res.wd.display()
        );

        Ok(Some(res))
    }

    /// Clones this configuration and strips out everything that's not needed to run
    /// the specified server.  Also generated any random values not yet set.
    pub fn prepare_for(&self, server: crate::servers::Name) -> Result<Self> {
        // destruct to make sure we consider every field of Config
        let Self {
            ref phc_url,
            ref wd,
            phc: _,
            transcryptor: _,
            auths: _,
        } = self;

        let mut config: Config = Config {
            phc_url: phc_url.clone(),
            wd: wd.clone(),
            phc: None,
            transcryptor: None,
            auths: None,
        };

        macro_rules! clone_only_server {
            ($server:ident) => {
                if crate::servers::$server::Server::NAME == server {
                    assert!(self.$server.is_some());
                    config.$server.clone_from(&self.$server);
                }
            };
        }

        for_all_servers!(clone_only_server);

        config.generate_randoms()?;

        Ok(config)
    }

    /// Creates a new [Config] from the current one by updating a specific part
    pub fn json_updated(&self, pointer: &str, new_value: serde_json::Value) -> Result<Self> {
        let mut json_config: serde_json::Value =
            serde_json::to_value(self).context("failed to serialize config")?;

        let to_be_modified: &mut serde_json::Value =
            json_config.pointer_mut(pointer).with_context(|| {
                format!(
                    "wanted to modify {} of the configuration file, but that points nowhere",
                    pointer
                )
            })?;

        to_be_modified.clone_from(&new_value);

        let new_config: Config = serde_json::from_value(json_config).with_context(|| {
            format!(
                "wanted to change {} of the configuration file to {}, but the new configuration did not deserialize",
                pointer,
                new_value,
            )
        })?;

        Ok(new_config)
    }
}

pub mod phc {
    use super::*;

    #[derive(serde::Deserialize, serde::Serialize, Debug, Clone)]
    #[serde(deny_unknown_fields)]
    pub struct ExtraConfig {
        /// Where can we reach the transcryptor?
        pub transcryptor_url: Url,

        /// Where can we reach the authentication server?
        pub auths_url: Url,

        /// The hubs that are known to us
        pub hubs: Vec<hub::BasicInfo>,

        /// `x_PHC` from the whitepaper; randomly generated if not set
        pub master_enc_key_part: Option<elgamal::PrivateKey>,
    }
}

pub mod transcryptor {
    use super::*;

    #[derive(serde::Deserialize, serde::Serialize, Debug, Clone)]
    #[serde(deny_unknown_fields)]
    pub struct ExtraConfig {
        /// `x_T` from the whitepaper; randomly generated if not set
        pub master_enc_key_part: Option<elgamal::PrivateKey>,
    }
}

pub mod auths {
    use super::*;

    #[derive(serde::Deserialize, serde::Serialize, Debug, Clone)]
    #[serde(deny_unknown_fields)]
    pub struct ExtraConfig {}
}

/// Trait to generate the random values in [Config] where needed
trait GenerateRandoms {
    fn generate_randoms(&mut self) -> anyhow::Result<()>;
}

impl GenerateRandoms for Config {
    fn generate_randoms(&mut self) -> anyhow::Result<()> {
        macro_rules! gen_randoms {
            ($server:ident) => {
                if let Some(ref mut server) = self.$server {
                    server.generate_randoms()?;
                }
            };
        }

        for_all_servers!(gen_randoms);

        Ok(())
    }
}

impl<Extra: GenerateRandoms + GetServerType> GenerateRandoms for ServerConfig<Extra> {
    fn generate_randoms(&mut self) -> anyhow::Result<()> {
        self.self_check_code
            .get_or_insert_with(crate::misc::crypto::random_alphanumeric);

        self.jwt_key.get_or_insert_with(api::SigningKey::generate);
        self.enc_key.get_or_insert_with(elgamal::PrivateKey::random);

        self.admin_key.get_or_insert_with(|| {
            let sk = api::SigningKey::generate();

            log::info!(
                "{} admin key: {}",
                Extra::ServerT::NAME,
                serde_json::to_string(&sk)
                    .expect("unexpected error during serialization of admin key")
            );

            sk.verifying_key().into()
        });

        self.extra.generate_randoms()?;

        Ok(())
    }
}

impl GenerateRandoms for transcryptor::ExtraConfig {
    fn generate_randoms(&mut self) -> anyhow::Result<()> {
        self.master_enc_key_part
            .get_or_insert_with(elgamal::PrivateKey::random);

        Ok(())
    }
}

impl GenerateRandoms for phc::ExtraConfig {
    fn generate_randoms(&mut self) -> anyhow::Result<()> {
        self.master_enc_key_part
            .get_or_insert_with(elgamal::PrivateKey::random);

        Ok(())
    }
}

impl GenerateRandoms for auths::ExtraConfig {
    fn generate_randoms(&mut self) -> anyhow::Result<()> {
        Ok(())
    }
}

/// Used to implement the `server_config` method on `crate::servers::<SERVER>::Details`.
pub trait GetServerConfig {
    type Extra;

    fn server_config(config: &Config) -> &ServerConfig<Self::Extra>;
}

macro_rules! implement_get_server_config {
    ($server:ident) => {
        impl GetServerConfig for crate::servers::$server::Details {
            type Extra = crate::servers::config::$server::ExtraConfig;

            fn server_config(config: &Config) -> &ServerConfig<Self::Extra> {
                &config.$server.as_ref().unwrap()
            }
        }
    };
}

for_all_servers!(implement_get_server_config);

/// Used to implement the `ServerT` associated type of `<SERVER>::ExtraConfig`.
trait GetServerType {
    type ServerT: crate::servers::Server;
}

macro_rules! implement_server_type {
    ($server:ident) => {
        impl GetServerType for $server::ExtraConfig {
            type ServerT = crate::servers::$server::Server;
        }
    };
}

for_all_servers!(implement_server_type);
