//! User endpoints for entering hubs
use std::rc::Rc;

use curve25519_dalek::RistrettoPoint;

use crate::api;
use crate::id;

use serde::{Deserialize, Serialize};

use super::server::*;
use crate::api::phc::user::*;
use crate::api::sso::*;

impl App {
    /// Implements [`PppEP`].
    pub(crate) async fn handle_user_ppp(
        app: Rc<Self>,
        auth_token: actix_web::web::Header<AuthToken>,
    ) -> api::Result<PppResp> {
        let running_state = app.running_state_or_please_retry()?;

        let Ok((user_state, _)) = app
            .open_auth_token_and_get_user_state(auth_token.into_inner())
            .await?
        else {
            return Ok(PppResp::RetryWithNewAuthToken);
        };

        let now = api::NumericDate::now();

        let nonce_inner = PpNonceInner {
            user_id: user_state.id,
            not_valid_after: now + app.pp_nonce_validity,
            issued_at: now,
        };

        Ok(PppResp::Success(api::Sealed::new(
            &PolymorphicPseudonymPackage {
                // we make sure to rerandomize the polymorphic pseudonym so the transcryptor cannot
                // track the user based on it
                polymorphic_pseudonym: user_state.polymorphic_pseudonym.rerandomize(),
                nonce: api::Sealed::new(&nonce_inner, &app.pp_nonce_secret)?.into(),
            },
            &running_state.t_sealing_secret,
        )?))
    }

    /// Implements [`HhppEP`].
    pub(crate) async fn handle_user_hhpp(
        app: Rc<Self>,
        req: actix_web::web::Json<HhppReq>,
        auth_token: actix_web::web::Header<AuthToken>,
    ) -> api::Result<HhppResp> {
        let running_state = app.running_state_or_please_retry()?;

        let Ok(auth_token_user_id) = app.open_auth_token(auth_token.into_inner()) else {
            return Ok(HhppResp::RetryWithNewAuthToken);
        };

        let req = req.into_inner();

        let Ok(EncryptedHubPseudonymPackage {
            encrypted_hub_pseudonym,
            hub_nonce,
            phc_nonce,
        }) = req.ehpp.open(&running_state.t_sealing_secret)
        else {
            log::debug!("invalid Ehpp submitted to Hhpp endpoint");
            return Ok(HhppResp::RetryWithNewPpp);
        };

        let Ok(PpNonceInner {
            user_id: phc_nonce_user_id,
            issued_at: pp_issued_at,
            not_valid_after,
        }) = api::Sealed::<PpNonceInner>::from(phc_nonce).open(&app.pp_nonce_secret)
        else {
            log::info!("Ehpp containing invalid PHC nonce submitted to Hhpp endpoint");
            return Ok(HhppResp::RetryWithNewPpp);
            // this is not so dramatic, since the key used to seal PHC nonces may change regularly
        };

        if phc_nonce_user_id != auth_token_user_id {
            log::warn!("user {auth_token_user_id} used {phc_nonce_user_id}'s PP nonce");
            return Err(api::ErrorCode::BadRequest);
        }

        if not_valid_after < api::NumericDate::now() {
            log::debug!("Ehpp containing expired PHC nonce submitted to Hhpp endpoint");
            return Ok(HhppResp::RetryWithNewPpp);
        }

        let Some(hub_pseudonym) =
            encrypted_hub_pseudonym.decrypt_and_check_pk(&app.master_enc_key_part)
        else {
            log::warn!("hub pseudonym was encrypted for the wrong public key");
            return Err(api::ErrorCode::InternalError);
            // Internal error, because the encrypted_hub_pseudonym is guaranteed to be
            // generated by the transcryptor, and the master encryption key should not have changed
            // if the sealing secret is still valid.
        };

        let hashed_hub_pseudonym: api::CurvePoint =
            RistrettoPoint::hash_from_bytes::<sha2::Sha512>(hub_pseudonym.compress().as_bytes())
                .compress()
                .into();

        Ok(HhppResp::Success(api::Signed::new(
            &*app.jwt_key,
            &HashedHubPseudonymPackage {
                hashed_hub_pseudonym,
                pp_issued_at,
                hub_nonce,
            },
            app.pp_nonce_validity, // not sure if we should get a seprate configuration field for
                                   // Hhpp's validity duration
        )?))
    }
}

/// The contents of a [`PpNonce`].
#[derive(Serialize, Deserialize, Debug)]
struct PpNonceInner {
    /// When this nonce expires.
    not_valid_after: api::NumericDate,

    /// When this nonce was issued
    issued_at: api::NumericDate,

    /// The [`id::Id`] of the user requesting this [`PolymorphicPseudonymPackage`].
    user_id: id::Id,
}

api::having_message_code!(PpNonceInner, PpNonce);

impl From<api::Sealed<PpNonceInner>> for PpNonce {
    fn from(sealed: api::Sealed<PpNonceInner>) -> Self {
        Self {
            inner: sealed.inner,
        }
    }
}

impl From<PpNonce> for api::Sealed<PpNonceInner> {
    fn from(nonce: PpNonce) -> Self {
        nonce.inner.into()
    }
}
